# 200507_





# 200317_W1D1_데이터베이스관리



1-2 주차는 선행과목 복습



3주차부터 본격적으로 진도 나감.





팀프로젝트는 있지만 큰 규모는 아님.





## 평가

##### 중간 기말 합쳐서 50%

##### 팀 프로젝트 40%

##### 출석이 10%

![1584422132593](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1584422132593.png)



##### 학기말에 팀 프로젝트 발표



2인1조, 3인1조로 구성



온라인 강의 2주 지나고 난 뒤 팀 편성



## 학습계획

![1584422734958](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1584422734958.png)





주 4시간 강의, 



주 2시간은 강의

주 2시간은 실습으로 운영됨.





트랜잭션 : 하나의 완벽한 DBMS 쿼리를 수행한 결과를 저장

Concurrency : 데이터 베이스에 동시 접근하는 엑세스를 어떻게 관리하는가?



BI : 데이터를 기반으로 의사결정 하는 것



BI와 빅데이터는 범위 자체가 광범위 하기 때문에 간략하게만 다룸.





# 200319_W1D2_데이터베이스용어정리



처음 1-2주차는 예전(데이터베이스 설계) 과목의 리뷰임.





DB의 기술이 총집합 되어있는 소프트웨어가 **DBMS(Data-Base Management Systems)**



![1584580176944](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1584580176944.png)



## 예시 1. 유통회사의 데이터 관리 - 엑셀



이런 엑셀로 데이터를 관리할 시 문제점이 발생할 수 있다.

Redundancy 

- Duplication of data or the storing of the same data in more than one place

데이터 중복 ex) 고객의 정보가 담겨있는 엑셀파일을 여러 부서에서 따로 관리할 경우 정보가 업데이트 될 경우 일일히 다 바꿔주어야한다.



Difficulty accessing data

데이터양이 많아지면 원하는 데이터에 접근이 어렵다



Limited security

보안이 제한됨. -> 중요한 개인 정보에 대한 접근 권한 등을 설정하기 힘듬 



Size limitations 

크기에 한계가 있음.



#### 데이터 무결성이란?

**데이터 무결성**(영어: **data integrity**)은 데이터의 정확성과 일관성을 유지하고 보증하는 것





## 유통 회사의 구조

![1584581625738](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1584581625738.png)



구매, 회계,재고,판매 부서가 있음

Vendors 는 공급업체.







각 부서마다 요구하는 데이터가 다름.

![1584583355097](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1584583355097.png)





## 파일 시스템의 기본 구조

Basic constructs:



- A collection of application programs that perform services for the end users (e.g. reports).

최종 유저에게 필요한 기능들의 집합이어야함.



- Each system defines and manages its own data.

각 시스템은 고유의 데이터를 소유하고 운영할 수 있어야함.



- Data file

  - File used to store data
  - Computer counterpart to ordinary paper file

  데이터는 파일 시스템에 저장된 내부 데이터를 사용한다. 



## 파일 시스템의 단점

##### Uncontrolled data redundancy - 통제되지 않는 파일 중복의 문제가 생기는 경우.



##### Data inconsistency - 데이터 불일치의 문제가 생기는 경우.

♥Provides inconsistent information depending on the data sources



##### Poor data sharing - 파일 공유 기능의 부적합이 생기는 경우.

♥Incompatible file formats

♥Difficulty of getting quick answers



##### Lack of security - 보안성이 부족한 경우



##### High maintenance cost - 유지 보수 비용이 매우 커지는 경우

​	♥Difficult to keep up with changes

​			♣Data dependence -File structure is defined in the program code.

​			♣Fixed Queries/Proliferation of application programs

​			♣Programs are written to satisfy particular functions. 

​						♠Any new requirement needs a new program.





## DBMS의 등장



![1584584673125](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1584584673125.png)





각각 부서의 파일 시스템에서 관리하던 것을 DB라는 이름으로 모아서 한꺼번에 관리하는 소프트 웨어 







## DBMS의 정의



Database 

- an organized collection of related data - 조직화되고, 관계가 있는 데이터들의 집합.



Database management system (DBMS)

- Program, or collection of programs, through which users interact with a database

  유저와 상호 작용하는 데이터베이스 프로그램 or 프로그램의 집합

  

- Popular DBMSs: Access, Oracle, DB2, MySQL, and SQL Server

  주로 위에 있는 종류의 DBMS가 사용된다 (RDBMS - 관계형 데이터베이스)



Database design

- Determining the structure of the required database

  데이터에 필요한 구조를 결정하는 것을 **데이터베이스 설계**라고 한다.





## 주문 데이터 예시

![1584585516482](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1584585516482.png)



#### 각각의 테이블에 필요한 항목들



Sales Reps

- Sales rep number, last name, first name, address, total commission, commission rate



Customers

- Customer number, name, address, current balance, credit limit, customer sales rep



Parts Inventory

- Part number, description, number units on hand, item class, warehouse number, unit price



Items for each customer’s order

- Order
  - Order number, order date, customer number
- Order line
  - Order number, part number, number of units ordered, quoted price
- Overall order total
  - Not stored because it can be calculated







## 데이터 베이스 용어

#### Database 

- Structure that can store information about: 
  - Different categories of information
  - Relationships between those categories of information



#### Entity 

-자료를 저장할 대상(테이블)

- Person, place, object, event, or idea
- Entities for Premiere Products: sales reps, customers, orders, and parts



#### Attribute

-Entity의 특징을 나타내는 자료 항목들. - field 나 column이라고도 부른다.

- Characteristic or property of an entity
- Example: Customer has name, street, city, etc.
  - May also be called a **field** or **column**



#### Relationship 

-Entity 간의 관계. 1:1 1:다 등이 있다.

- Association between entities
- One-to-many relationship 
  - Each rep is associated with many customers
  - Each customer is associated with a single rep



## 





# 200324_W2D1_DBMS 관련 정리



#### Relationship 

-Entity 간의 관계. 1:1 / 1:다 / 다:다등이 있다.

- Association between entities
- One-to-many relationship 
  - Each rep is associated with many customers
  - Each customer is associated with a single rep



두 종류 이상의 entity 들 사이에서의 관계가 있을 수 있다.





### 1:다 관계 예시 =  판매원(1) : 고객(다) 



![1585026547269](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585026547269.png)



직원 한명이 고객 여러명을 담당할 수 있다.



직원이나 고객 entity를 구성하는 요소들을 Attributes라고 한다.



![1585026596284](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585026596284.png)

![1585026613071](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585026613071.png)



RepNum을 고객 entity가 Foriegin key로 가져오면서 1:다 관계가 생성된다.



balance는 외상으로 구매한 금액

Credit Limit은 한계



842번 같은 경우에는 한도를 초과하였기 때문에 20번 사원이 잘 관리 해줘야한다.





### 예시2 - 주문, 주문품목표 

##### 주문(1): 주문품목(다) 의 관계이다.

![1585027489269](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585027489269.png)



21610의 주문을 보면 주문은 1번이지만 주문품목이 2번인걸 볼 수 있다. (1:다)







위의 데이터베이스를 엑셀로 만들면?

![1585027595056](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585027595056.png)



이런 식으로 만들어진다.







## E-R Diagram

![1585027802435](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585027802435.png)



entity 와 Relationship을 나타내는 다이어그램



RepNum이나 CustomerNum 등 값들을 구분하는데 주로 사용되는 Attribute를 Key Attribute 라고 한다.



해당 Entity 만의 고유 식별 키는 Primary key

다른 Entity에서 가져온 식별 키는 Foregin key 라고 하며, Foregin key는 1:다의 관계일 경우 중복이 될 수 있다. (Primary key는 절대 중복 불가)







### 데이터베이스 접근법

![1585028477281](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585028477281.png)





사용자가 DBMS(DataBase Management System를 통해 직접 데이터베이스에 접근하거나



특정 프로그램을 통해 DBMS -> DB에 접근할 수 있다. (유저가 SQL을 모를 경우)



1-8의 경우는 데이터베이스를 설계, 관리 하는 사람들이고

1-9는 데이터베이스를 사용하는 유저,관리자 등이 이용을 한다.



즉 DB 설계자와 관리자가 따로 존재하는 경우도 있다.





### Forms , Reports

![1585028874015](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585028874015.png)



DBMS는 Forms(양식) 통해 데이터 베이스에 입력하는 양식을 만들거나

Reports(보고서) 등을 통해서 아웃풋을 쉽게 만들어낼 수 있다.





![1585028985606](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585028985606.png)





주문 폼 예시







## DB접근

![1585029014227](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585029014227.png)



각 부서에서 DBMS를 이용해서 DB에 직접 접근하거나 Meta Data에 접근할 수 있다.



Meta Data는 DB의 저장공간, 속성 등을 설명하는 데이터다.



- 데이터에 대한 데이터로써 하위레벨의 데이터를 설명/기술하려는 것
  - 상위레벨에서 하위레벨 데이터에 대한 각종 정보(자원의 속성)를 담고있는 데이터
  - 설명/기술 例) 문서 유형, 문서 구조, 문서 길이, 문서 작성자, 문서 작성일 등
- 즉, 자료 그 자체가 아닌 자료의 속성 등을 설명하는 데이터
  - 속성 例) 데이터에 관한 정보의 기술, 데이터 구성의 정의, 데이터의 분류 등을 위한 데이터 등





#### DBA?

DB의 Administrator 즉, 관리자를 뜻한다.









## DBMS의 기능들

- ##### Data dictionary management - 데이터 사전 관리

  - Data dictionary: stores definitions of data elements and their relationships

- ##### Data storage management - 데이터 저장소 관리 

  - Performance tuning ensures efficient performance 

- ##### Data transformation and presentation - 데이터 전환 및 표현

  - Data is formatted to conform to logical expectations

- ##### Security management - 보안관리

  - Enforces user security and data privacy 

- ##### Multiuser access control - 다중 접속 관리

  - Sophisticated algorithms ensure that multiple users can access the database concurrently without compromising its integrity



- ##### Backup and recovery management - 백업, 복원 관리

  - Enables recovery of the database after a failure

- ##### Data integrity management - 데이터 진실성 관리

  - Minimizes redundancy and maximizes consistency

- ##### Database access languages and application programming interfaces 

  ##### -데이터 베이스 관리를 위한 언어와 프로그래밍 인터페이스

  - Query language: lets the user specify what must be done without having to specify how 
  - Structured Query Language (SQL): de facto query language and data access standard supported by the majority of DBMS vendors

- ##### Database communication interfaces - 커뮤니케이션이 가능한 인터페이스 

  - Accept end-user requests via multiple, different network environments 







## 데이터 베이스의 장 단점



### 장점 



#### 1.Getting more information from the same amount of data - 같은 양의 데이터라도 얻게되는 정보의 양이 많아짐

#### 2.Sharing data - 데이터를 공유할 수 있게됨

#### 3.Balancing conflicting requirements - DB 유저간의 요구사항 충돌을 줄여줌.

- **Database administrator** or **database administration (DBA**): person or group in charge of the database

#### 4.Controlling redundancy - 중복을 관리할 수 있게 됨

#### 5.Facilitating consistency - 효율 일관성

#### 6.Improving integrity - 데이터 무결성을 향상시켜줌

- **Integrity constraint**: a rule that data must follow in the database

#### 7.Expanding security - 보안 확장

- **Security**: prevention of unauthorized access

#### 8.Increasing productivity - 생산성 향상

#### 9.Providing data independence - 데이터 독립성을 제공.

- **Data independence**: can change structure of a database without changing the programs that access the database





### 단점

#### 1.Increased costs - 비용이 증가

- DBMS, training, professional

#### 2.Greater impact of failure - 실패의 영향이 커짐

#### 3.Management complexity - 복잡성을 관리해야함

#### 4.Maintaining currency - 유지 하는데 힘이 든다.

#### 5.Vendor dependence - 공급자 의존적이게 된다.

#### 6.Frequent upgrade/replacement cycles -빈번한업그레이드를 할 때 마다 비용이 든다.







## 요약



- Problems with nondatabase approaches: redundancy, difficulties accessing related data, limited security features, limited data sharing features, and potential size limitations

데이터 베이스가 없을때의 문제점 : 중복문제 발생, 보안을 관리하는 시스템이 없음, 데이터사이즈가 제한되어있음, 데이터 공유가 힘듬

- Entity: person, place, object, event, or idea for which you want to store and process data

  =자료를 저장하는 대상, 테이블과 같은 개념

- Attribute, field, or column: characteristic or property of an entity

  =Entity의 특징들, 컬럼,필드 라고도 불림

- Relationship: an association between entities

  =관계, Entity들 사이의 연관성, 1:1이나 1:다, 다:다 같은 형식들이 있다.

- One-to-many relationship: 

  - each occurrence of first entity is related to many occurrences of the second entity and 
  - each occurrence of the second entity is related to only one occurrence of the first entity

=1:다 관계 , 하나의 Entity는 여러가지 2번째 entity을 가질 수 있다. 

=하지만 2번째 entity는 반드시 하나의 entity를 상위 entity로 가진다.









- Database: structure that can store information about multiple types of entities, attributes of entities, and relationships among entities

  =데이터베이스 : 정보를 다양한 구조(entites, attributes,relationships 등) 으로 저장할 수 있는 구조.

- Premiere Products requires information about reps, customers, parts, orders, and order lines

  =주요 제품은 고객, 재료, 주문, 생산라인 등등의  정보가 필요하다.

- Entity-relationship (E-R) diagram: represents a database visually by using various symbols

  = 실체 관계도, Entity와 Entity들 사이의 관계를 나타내는 관계도이다.

- Database management system (DBMS): 

  - program through which users interact with a database; 
  - lets you create forms and reports quickly and easily and obtain answers to questions about the data

  =데이터베이스 관리 시스템 : 크게 4개가 있음 - 오라클,mysql 등등

  ==사용자가 데이터베이스에 상호작용할 수 있는 프로그램이다.

  ==다양한 입력양식이나 보고서 등을 쉽게 만들 수 있는 기능들을 가지고 있다.



- Advantages of database processing: DB 의 장점

  - getting more information from the same amount of data, 

    =같은 양의 데이터라도 더 많은 정보를 얻을 수 있다.

  - sharing data, 

    = 정보의 공유가 가능해진다.

  - balancing conflicting requirements, 

    =자료에 대한 요구가 충돌하는 경우가 발생할 수 있을 경우 DB 설계자가 미리 사전에 방지핟록 설계할 수 있다.

  - controlling redundancy, 

    = 데이터 중복을 관리할 수 있다.

  - facilitating consistency, 

    = 일관성을 유지함.

  - improving integrity, 

    = 데이터무결성, 

  - expanding security, 

    =보안을 강화함

  - increasing productivity, 

    =생산성을 증가시킴

  - providing data independence

    =데이터 독립성을 제공, 프로그램과 데이터베이스 간에 독립성이 유지된다.

  

- Disadvantages of database processing: 

  - larger file size,

    = 파일의 크기가 커진다.

  - increased complexity,

    =복잡성이  증가한다.

  - greater impact of failure,

    =실패의 영향이 커진다. 

  - and more difficult recovery 

    =복구에 어려움을 겪는다.





# 200326_W2D2_데이터 모델



## 전 시간 요약

- Problems with nondatabase approaches: redundancy, difficulties accessing related data, limited security features, limited data sharing features, and potential size limitations

데이터 베이스가 없을때의 문제점 : 중복문제 발생, 보안을 관리하는 시스템이 없음, 데이터사이즈가 제한되어있음, 데이터 공유가 힘듬

- Entity: person, place, object, event, or idea for which you want to store and process data

  =자료를 저장하는 대상, 테이블과 같은 개념

- Attribute, field, or column: characteristic or property of an entity

  =Entity의 특징들, 컬럼,필드 라고도 불림

- Relationship: an association between entities

  =관계, Entity들 사이의 연관성, 1:1이나 1:다, 다:다 같은 형식들이 있다.

- One-to-many relationship: 

  - each occurrence of first entity is related to many occurrences of the second entity and 
  - each occurrence of the second entity is related to only one occurrence of the first entity

=1:다 관계 , 하나의 Entity는 여러가지 2번째 entity을 가질 수 있다. 

=하지만 2번째 entity는 반드시 하나의 entity를 상위 entity로 가진다.









- Database: structure that can store information about multiple types of entities, attributes of entities, and relationships among entities

  =데이터베이스 : 정보를 다양한 구조(entites, attributes,relationships 등) 으로 저장할 수 있는 구조.

- Premiere Products requires information about reps, customers, parts, orders, and order lines

  =주요 제품은 고객, 재료, 주문, 생산라인 등등의  정보가 필요하다.

- Entity-relationship (E-R) diagram: represents a database visually by using various symbols

  = 실체 관계도, Entity와 Entity들 사이의 관계를 나타내는 관계도이다.

- Database management system (DBMS): 

  - program through which users interact with a database; 
  - lets you create forms and reports quickly and easily and obtain answers to questions about the data

  =데이터베이스 관리 시스템 : 크게 4개가 있음 - 오라클,mysql 등등

  ==사용자가 데이터베이스에 상호작용할 수 있는 프로그램이다.

  ==다양한 입력양식이나 보고서 등을 쉽게 만들 수 있는 기능들을 가지고 있다.



- Advantages of database processing: DB 의 장점

  - getting more information from the same amount of data, 

    =같은 양의 데이터라도 더 많은 정보를 얻을 수 있다.

  - sharing data, 

    = 정보의 공유가 가능해진다.

  - balancing conflicting requirements, 

    =자료에 대한 요구가 충돌하는 경우가 발생할 수 있을 경우 DB 설계자가 미리 사전에 방지핟록 설계할 수 있다.

  - controlling redundancy, 

    = 데이터 중복을 관리할 수 있다.

  - facilitating consistency, 

    = 일관성을 유지함.

  - improving integrity, 

    = 데이터무결성, 

  - expanding security, 

    =보안을 강화함

  - increasing productivity, 

    =생산성을 증가시킴

  - providing data independence

    =데이터 독립성을 제공, 프로그램과 데이터베이스 간에 독립성이 유지된다.

  

- Disadvantages of database processing: 

  - larger file size,

    = 파일의 크기가 커진다.

  - increased complexity,

    =복잡성이  증가한다.

  - greater impact of failure,

    =실패의 영향이 커진다. 

  - and more difficult recovery 

    =복구에 어려움을 겪는다.





## Data Models

DB에 관련된 기술적 용어들 





비즈니스 룰 - 업무 규칙

비즈니스 룰을 DB에 적용시켜서 만들어야 한다. (ex 입학년도는 졸업년도보다 빠를 수 없다.)



![1585186444078](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585186444078.png)

##### 위의 그림 중요



디비 시스템을 구성하는 사람,요소들

End User = 최종 사용자, 각 업무의 담당자



Application programs = 업무용 프로그램 

-> DB에 데이터를 요청, 프로그래머와 분석가들이 프로그램을 만든다.





시스템 관리, DB 관리자(DBA)가 따로 있고 데이터베이스를 만들때 디자이너가 디자인을 한다.



디자이너가 디자인을 할때 분석가의 도움을 받는다.



DB설계자(디자이너)는 비즈니스룰이나 업무에 대한 이해가 있어야함.







### 데이터 모델의 중요성

- Diverse user groups - DB 유저의 다양성

  - Facilitates communication  

  - Gives various views of the database

  - Organizes data for various users 

  - Provides an abstraction for the creation of good a database

    -데이터베이스를 만들때 각각의 유저들의 추상적인 내용이 전달되어야 좋은 데이터베이스가된다.

    

  다양한 end user에 맞는 DB를 만드는 것이 중요하다.

  

- Data Model Basic Building Blocks - 데이터 베이스를 설계하기 위해선 아래 것들을 기본적으로 알아야 한다.

  - Entity
  - Attribute
  - Relationship: association among entities
    - One-to-many (1:M OR 1..*)
    - Many-to-many (M:N or *..*)
    - One-to-one (1:1 OR 1..1)
  - Constraint: restriction placed on data - 제약조건, 데이터 무결성을 확실히 해준다.
    - Ensures data integrity





### 데이터 구분 

![1585189280361](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585189280361.png)





#### 첸 노테이션

 사각형 엔터티, 마름모 릴레이션쉽, 마름모 왼,아래에 관계의 특징이 나와있음.



#### 크로우 풋 (까마귀 발) 노테이션 

1쪽은 ㅣㅣ같이 작대기 두개, M(다) 쪽은 ㅣ<  (삼지창)모양

선 위에  관계의 이름을 명시한다.



삼지창 모양이 새 발바닥 같다고 해서 크로우 풋노테이션임

![1585189772232](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585189772232.png)

##### I< 은 미니멈1, 맥시멈 many의 의미이다.

##### 0< 은 미니멈0, 맥시멈many



ll 은 최소1 최대1 즉 하나만을 의미한다.



#### UML class diagram 노테이션



![1585189478010](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585189478010.png)

1..1 

1...* 같은 식으로 **양쪽에** 표시해준다. 







#### 예시1

![1585190227167](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585190227167.png)



INVOICE = 발생품목



Customer : INVOICE : 1:M 관계 (0 to many) 

INVOICE : Line 은 1:M 관계이다. 







## Business Rules



- Brief, precise, and unambiguous description of a policy, procedure, or principle

  = 원리 규칙, 정책등을 정하는 업무규칙 

  - Create and enforce actions within that organization’s environment

    조직 환경에 맞는 룰을 만들어 주는 역할을 한다.

  - Establish entities, relationships, and constraints

    객체, 관계, 제약조건 등을 이용해 설립한다.

    

- Sources of business rules = 비즈니스 룰의 소스

  - Company managers, Policy makers - 회사 대표, 업무 규칙 생성자를 통해

  - Department manager - 각 부서 담당자들

  - Written documentation - 이미 쓰여진 문서를통해

  - Direct interviews with end users - 엔드 유저 등과 대화를 통해 알 수 있음 

    

- Reasons for identifying and documenting business rules 

  = 비즈니스 룰을 확실히 해야 하는 이유

  - Standardize company’s view of data - 회사의 관점의 데이터를 표준화 할 수 있다.

  - Facilitate communications tool between users and designers - 유저와 설계자들의 대화 수단이 된다.

  - Assist designers - 설계자를 도와주는 역할을 한다.

    - Understand the nature, role, scope of data, and business processes

      -역할, 데이터의 본질 범위 등등을 표현 및 알게 해줌.

    - Develop appropriate relationship participation rules and constraints

      -관계나 원리, 룰, 제약조건을 만드는데 도움이 된다.

    - Create an accurate data model

      -정확한 데이터 모델을 만드는데 도움이 된다.





여러가지 형태의 비즈니스 룰이 존재한다,



데이터베이스 설계자가 이러한 룰을 데이터베이스 규칙으로 바꿔주어야 한다.



## Translating Business Rules into Data Model

- Business rules set the stage for the proper identification of entities, attributes, relationships, and constraints
  - Nouns translate into entities
  - Verbs translate into relationships among entities
- Relationships are bidirectional
  - Questions to identify the relationship type
    - How many instances of B are related to one instance of A?
    - How many instances of A are related to one instance of B?
- Entity name requirements 
  - Be descriptive of the objects in the business environment
  - Use terminology that is familiar to the users
- Attribute name 
  - Required to be descriptive of the data represented by the attribute 
- Proper naming
  - Facilitates communication between parties
  - Promotes self-documentation





# 200331_W3D1_데이터모델2, 추상화

## 전 시간 리뷰

## Translating Business Rules into Data Model

- Business rules set the stage for the proper identification of entities, attributes, relationships, and constraints

  - Nouns translate into entities

- Verbs translate into relationships among entities

    

- Relationships are bidirectional

  - Questions to identify the relationship type - 사용자가 찾아야 하는 관계형 타입

    - How many instances of B are related to one instance of A?

    A라는 인스턴스 종류 한건이 B라는 인스턴스 몇건에 관련이 있는가?

    - How many instances of A are related to one instance of B?

      B라는 인스턴스 종류 한건이 A라는 인스턴스 몇건에 관련이 있는가?

      

- Entity name requirements - 엔티티 이름을 설정해야 할 경우

  - Be descriptive of the objects in the business environment - 비즈니스 환경에 맞게 설정

- Use terminology that is familiar to the users - 사용자들에게 친숙한 이름을 사용

    

- Attribute name  - 어트리뷰트 이름

  - Required to be descriptive of the data represented by the attribute 

    -이름은 데이터를 잘 나타낼 수 있도록 명확히 해야한다.





- Proper naming - 적절한 이름 짓기
  - Facilitates communication between parties - 그룹 구성원들 사이에서 소통이 원활하게
  - Promotes self-documentation - 서로 표준화가 이루어 지도록 해야함.







## 데이터 모델의 역사(pdf.2 이어서)



![1585631704767](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585631704767.png)







처음에는 **계층적 구조 모델**( - 수직적 데이터만을 설명) 밖에 없는 줄 알았는데, 그 후

 

**망형 데이터 모델** - 수평의 데이터를 설명할 순 있지만 데이터 간의 관계를 설명하기가 힘듬.



**관계형 데이터 모델** - 70년대에 이론으로 먼저 등장



E**ntity 관계형 모델** - 76년에 E-R 모델이 등장, 그래프나 그림으로 표현을 할 수 있는 개념적 모델이 생성됨.



**의미형(Semantic) 데이터 모델** 

- 객체지향형(Object-Oriented) - 데이터들을 각각의 객체로 보는 모델
- 확장된 관계형(O/R DBMS) -object(객체)들을 다룰 수 있는 모델

E-R 모델로 설명하지 못 했던 관계를 추가, 데이터들의 의미를 생각해서 데이터 모델링을 하는 것.



**NoSQL**

-비정형 데이터, 외부의 데이터들을 가져올 때 형태나 값들, 구조를 모르기 때문에 비정형 데이터라고 한다. 이러한 비정형 데이터를 관리하는 기술이 NoSQL이라 한다.



순으로 개발되었다.







## Emerging Data Models



##### Goals of Big Data

- Find new and better ways to manage large amounts of web and sensor-generated data

  -많은 양의 데이터들 중에서 조직이 관심을 둘만한 데이터들을 추출해야한다.

- Provide high performance at a reasonable cost  

  -적절한 비용으로 고 성능을 낼 수 있도록 해야한다.

  

##### Characteristics of Big Data 

- Volume, Velocity, Variety, Veracity

  -빅데이터의 특징, 원래는 3V였다가 4V로 바뀜 : 크기,속도,다양성,진실성

  

  다루는 데이터의 양이 많아진다.

  데이터를 처리하거나 수집하는 속도 또한 중요하다.

  다양한 타입의 데이터를 다룬다.

  fake데이터를 긁어 모아봐야 의미가 없다.

  

  

##### Challenges of Big Data 

- Volume doesn’t allow usage of conventional structures 

  -데이터 양이 많아졌기 때문에 정형화 된 구조로 다루는 것이 힘들어진ㄴ.

- Expensive

  -비용 문제

- OLAP tools proved inconsistent dealing with unstructured data

  -축적된 정형화된 데이터들을 분석하여 OLAP이라는 도구가 등장함.

  -온라인 분석 처리(Online Analytical Processing, **OLAP**)



##### New technologies of Big Data - 빅데이터  신기술

- Hadoop - 하둡
- Hadoop Distributed File System (HDFS) - 하둡 파일 분산 처리 시스템(하둡에서 제공)
- MapReduce - 맵리듀스(하둡에서 제공) , 데이터 병렬처리를 위한 프로그램
- NoSQL - 비정형화된 데이터들을 저장하기 위한 기술





#### NoSQL databases

- Not based on the relational model - 관계형 모델에 기초하지 않음.

  

- Support distributed database architectures - 분산 데이터 베이스 구조를 지원

  

- Provide high scalability, high availability, and fault tolerance

  -scalability - 규모가 얼마나 크든 작든 처리가 가능해야한다.

  -availability - 그룹 내 유저의 누구나 활용 가능해야한다.

  -fault tolerance - 장애 허용 시스템, 고장이 나더라도 부분적으로 기능을 수행할 수 있어야 한다.

  

- Support large amounts of sparse data

  많은 양의 흩어진 데이터(산발적인?)들을 지원해줌.

  

- Geared toward performance rather than transaction consistency

  NoSQL은 transaction 일관성보다 기본 성능이 매우 중요하다. 

  *기업에서 다루는 정형화된 데이터에서는 transaction처리가 매우 중요함(ex-은행에서 입출금 등이 동시에 일어나는 것을 다루는 일)

  

- Provides a broad umbrella for data storage and manipulation 

  폭 넓은 우산을 제공한다 - 많은 데이터 양을 저장하고 다룰 수 있게 해줌.





## Degrees of Data Abstraction - 데이터 추상화의 계층



![1585633566095](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585633566095.png)



End-User들은 데이터베이스의 내부가 궁금한게 아니라 자신의 업무와 관련되어 필요한 데이터들 만을 원함.



##### Logical independence - Conceptuual Model과 Internal Model은 서로 독립적이다.



##### Physical independence - DBMS가 보는 Internal Model과 어떻게 저장이 되는지에 대한 Physical Model은 서로 독립적이다.



##### Degree of Abstraction - 추상화의 수준, 위로 갈 수록 추상화의 수준이 높고 아래로 갈수록 낮다.

ER>객체지향>관계형>Network,계층형 순으로 추상화의 수준이 높다.



### 이러한 EndUser들이 보는 시점의 모델을 External Model 이라 한다.



![1585634086563](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585634086563.png)

##### 학생 등록에 대한 모델설명

end-user가 학생일 때, 학생이 수강신청을 하는 과정의 DB 모델

enroll은 원래는 등록이지만 한 학기 등록 하는 등록과 혼동이 올 수 있기 때문에 과목에 대한 수강신청으로 이해하면 됨.

class는 과목

course는 분반



student-enroll은 1대다의 관계, 학생 한명이 여러개의 수강 과목을 신청할 수 있다.



course(과목)은 여러개의 분반(class)을 가질 수 있다.



##### 과목 스케쥴링에 대한 모델 설명



하나의 강의실은 여러개의 분반(class)을 가질 수 있다. 



분반(class)들은 과목(course)과 1:1이거나 다:1 관계이다.



교수는 여러개의 분반(class)을 가질 수 있다.





#### 학생 등록, 과목 스케쥴링 모두 end user 의 관점임.





### Conceptual Model - 개념적인 모델 , DB 설계자가 만들고 가지고 있다.

 많은 External Model이 어떻게 얽힌 상태로 만들지 등을 구상하여 설계자가 구현해야한다.



![1585634101708](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585634101708.png)



위의 학생등록, 강의 관리를 합친 DB의 개념적 모델.

학생이 여러가지의 강의를 등록할 수 있고, 그러한 등록은 여러개의 분반이 가능하다 

(즉 한번의 수강신청으로 여러개의 분반 가능)



그 밖에도  교수,강의,강의실은 각각 여러개의 분반을 할당 받을 수 있는

1:다 관계가 된다.



### Internal Model - 관계형 데이터 베이스가 보는 데이터 베이스들의 모델 

즉 모든 데이터 베이스(학생DB,강의DB,교수DB등등)를 하나의 테이블로 보는 모델 (DBMS가 보는 관점의 모델, DBA가 관리)

![1585634117956](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585634117956.png)



좌측이 개념모델, 우측이 내부 모델



교수는 하나의 분반만을 맡을 수 있음.(다:다 관계 방지)



개념 모델을 실제 DB에 적용하기 위해서 각각의 요소들을 테이블로 만들어 준다.



식별키를 이용해서 관계를 설정한다. (1:1, 1:다,다:다)

ex)

![1585636071070](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585636071070.png)



1쪽의 PK를 다쪽의 FK로 넣어준다.



class의 경우 course,professor,room 3가지 항목을 FK으로 받는다.



### Physical Model : 실제 데이터가 저장될 때에 대한 데이터 모델



![1585634132712](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585634132712.png)



대부분 관계형 모델은 B+ Tree 구조로 테이블을 저장한다.



관계형 데이터 모델을 **테이블**로 저장한다.



어떻게 테이블로 저장하는가? 



![1585636471050](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585636471050.png)

이 테이블의 요소 하나 하나를 저장한다고 생각하면 됨.



row를 기준으로 한 줄 한 줄 씩 트리 형태로 저장한다.



*row와 record는 같은 의미, 

row는 테이블에서 사용 하는 용어, record는 IT업계에서 예전부터 써왔던 용어







![1585636708676](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585636708676.png)



각각의 정보(물리적 주소)를 한 node로 저장하고 포인터를 이용해 다음 node로 표시해준다.







#### 이런 게 있구나 정도만 알아두면 됨.

#### 각 4가지 모델의 용어와 의미를 알아둬야함.



# 200402_W3D2_관계형 데이터 모델

#### 

## 목표

- Identify the relational model’s basic components and explain the structure, contents, and characteristics of a relational table

  관계형 모델의 구조와 요소 특징, 등등을 설명할 수 있어야 함.

- Explain the purpose and components of the data dictionary and system catalog

  시스템 카탈로그 = 데이터 딕셔너리에 관한 것 

- Identify appropriate entities and then the relationships among the entities in the relational database model

  entities와 관계형 모델을 설명할 수 있어야함

- Describe how data redundancy is handled in the relational database model

  관계형 모델의 데이터 중복 관리법

- Explain the purpose of indexing in a relational database

  인덱싱 -> 검색시간 간소화







## Tables and Their Characteristics

![1585790439157](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585790439157.png)



여기 나중에 해석



#### 관계형 테이블의 특징

1.테이블은 행,열 구조

2.각 테이블의 행(투플)은 하나의 Single entity set이라 보면 된다.

3.각 테이블의 열은 attribute라 하며, 각각 다른 이름을 갖는다.

4.행과 열 데이터들이 모여서 하나의 Single data value가 된다. 

5.모든 열의 데이터는 같은 데이터 형식을 가져야 한다.

6.각 열은 특정 범위의 도메인을 가진다. (값의 범위를 설정 가능)

7.행과 열의 순서는 DMBS에서 중요하지 않다.(immaaterial)

8.각 테이블은 유니크한 attribute를 갖는다.





## Table

![1585790863274](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585790863274.png)



관계표, 12개의 속성



![1585790882493](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585790882493.png)



속성의 이름





## Keys

- Keys consist of one or more attributes that determine other attributes

  - Ensure that each row in a table is uniquely identifiable - 각 행을 유니크하게 식별할 수 있다.

  - Establish relationships among tables and to ensure the integrity of the data - 각 테이블 간의 관계 설정을 가능하게 해준다.

    

- Primary key: attribute or combination of attributes that uniquely identifies a row

  ##### 프라이머리 키 : Attribute 중에서 유니크하게 그 열을 식별해 낼 수 있는 Attribute(테이블의 요소 하나)

  - Composite key: key that is composed of more than one attribute

  - Key attribute: attribute that is a part of a key

  - Entity integrity: condition in which each row in the table has its own unique identity 

    - All of the values in the primary key must be unique
    - No key attribute in the primary key can contain a null 
    - Null: absence of any data value

  - Referential integrity: every reference to an entity instance by another entity instance is valid 

    -참조 무결성, **Constraint(제약조건)** 을 바탕으로 데이터베이스의 정확성을 지키는 것 

  - Foreign key: primary key of one table that has been placed into another table to create a common attribute

    -일명 **외래키** 다른 테이블의 프라이머리 키를 Attribute로 가져온 경우 Foregin Key가 된다. 

    -일대다 의 관계에서는 항상 다쪽에서 외래키를 가진다.

    

- Secondary key: key used strictly for data retrieval purposes



프라이머리키는 오직 하나만 가질 수 있고 포린키는 여러개 가질 수 있다.





### 예시1 공통자료항목

![1585791885187](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585791885187.png)







같은 Attribute가 있을 때, 자연스럽게 관계 설정이 됨.







### Null값 Handling

![1585791919581](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585791919581.png)



Flags

- NULL값을 표시하기 위한 특정 값

  ex) 날짜 데이터의 Flags는 2099-99-99

  

NOT NULL 제약조건 

- 테이블의 특정 열에 NULL 값을 가질 수 없게 제약조건을 주는 것



UNIQUE 제약조건

- 테이블의 특정열에 중복값을 가질 수 없게 제약조건을 주는 것









## Data Dictionary and the System Catalog 



- Data dictionary

  - Description of all tables in the database created by the user and designer 

    모든 테이블에 관한 자료 

- System catalog

  - System data dictionary that describes all objects within the database 

    모든 objects에 대한 정보를 다루는 시스템 데이터 딕셔너리

- Homonyms and synonyms must be avoided to lessen confusion

  바람직하지 않은 오류2개

  - Homonym: same name is used to label different attributes 

    이름은 같은데 실제론 서로 다른 Attributes

  - Synonym: different names are used to describe the same attribute

    이름은 다른데 내용이 같을때.

    

    



### Relationships within the Relational Database

관계형 데이터 베이스의 관계



- One-to-many (1:M) 1:다

  - Norm for relational databases 

    

- One-to-one (1:1)  1:1

  - One entity can be related to only one other entity and vice versa 

    

- Many-to-many (M:N) 다:다

  - Implemented by creating a new entity in 1:M relationships with the original entities 
  - Composite entity (i.e., bridge or associative entity): helps avoid problems inherent to M:N relationships
    - Includes the primary keys of tables to be linked



다:다의 구현은 Composite entity, 혹은 associative entity 를 만들어서 중간에서 합쳐주는 entity를 만들면됨.

아래 사진에서의 ENROLL이 예시



![1585793331319](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585793331319.png)



학생은 여러개의 분반을 가지고, 하나의 분반은 여러명의 학생을 가지므로 M:N

중간에 수강(ENROLL)이라는 entity를 만들어줌.

ENROLL이라는 관계표에는 student의 key, class의 key값이 각각 저장되어있다.





### Data Redundancy - 데이터 중복



- The relational DB facilitates control of data redundancies through use of foreign keys

  - Common attributes that are shared by tables

    데이터 중복은 DB에서 처리해줌. 동일 attributes는 테이블에서 공유된다.

- To be controlled except the following circumstances:

  - Sometimes data redundancy must be increased to make the database serve crucial information purposes

  - Sometimes data redundancy exists to preserve the historical accuracy of data

    여러 상황에서 데이터 중복이 허용될 수 있다. (다:다 의 공통 자료항목 같은)



![1585793730983](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585793730983.png)









## Indexs



데이터 베이스의 검색 기능을 도와주는 INDEX



- Orderly arrangement to logically access rows in a table

  - Index key: index’s reference point that leads to data location identified by the key

  - Unique index: index key can have only one pointer value associated with it

    INDEX 테이블을 만들어서 검색을 도와준다.

- Each index is associated with only one table

  - The index key can have multiple attributes





![1585794508812](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585794508812.png)



인덱스 테이블(왼쪽)을 통해 저장된 행의 주소(Pointers)를 통해 바로 해당 작가의 그림들로 이동할 수 있다.



index는 오른쪽 그림 같은 형태라 이해하면 됨.











## E-R 모델(PPT4)



### 목표 

- Identify the main characteristics of entity relationship components

  entity 관계의 요소들의 특징들을 확인

- Describe how relationships between entities are defined, refined, and incorporated into the database design process

- See how ERD components affect database design and implementation

- Understand that real-world database design often requires the reconciliation of conflicting goals



표준화를 따라 모델을 만들어서 충돌을 줄이는 것





### The Entity Relationship Model (ERM)



- Entities
  - Refers to the entity set and not to a single entity occurrence
  - corresponds to a table—not to a row—in the relational environment
  - refers to a table row as an entity instance or entity occurrence
  - represented by a rectangle that contains the entity’s name
  - The entity name is usually written in all capital letters



![1585795603468](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1585795603468.png)



각 entity(table)은 E-R에서 대문자로 표현하는 것이 관행





## Attributes



- Characteristics

  - Required attribute: must have a value and cannot be left empty (반드시 값을 가져야하는 특성)

    

  - Optional attribute: does not require a value and can be left empty

    

  - Domain: set of possible values for a given attribute 

    값의 제한 범위

    

  - Identifier: one/more attributes that uniquely identify each entity instance

    key같은 의미, attribute를 구분하는 유니크한 값

    - Composite identifier: primary key composed of more than one attribute

      

  - Composite attribute: attribute that can be subdivided to yield additional attributes (ex; address)

    여러개의 속성을 합쳐서 하나로 부르는 것

    

  - Simple attribute: attribute that cannot be subdivided

    더이상 나눠지지 않는 특성

    

  - Single-valued attribute: attribute that has only a single value

    

  - Multivalued attributes: attributes that have many values

    - Create several new attributes, one for each component of the original multivalued attribute

    - Develop a new entity composed of the original multivalued attribute’s components

      

  - Derived attribute: whose value is calculated from other attributes

    - Derived using an algorithm 



# 200407_W4D1_속성,관계,설계





## Attributes



- Characteristics

  - Required attribute: must have a value and cannot be left empty (반드시 값을 가져야하는 특성)

    

  - Optional attribute: does not require a value and can be left empty

    

  - Domain: set of possible values for a given attribute 

    값의 제한 범위

    

  - Identifier: one/more attributes that uniquely identify each entity instance

    key같은 의미, attribute를 구분하는 유니크한 값

    - Composite identifier: primary key composed of more than one attribute

      

  - Composite attribute: attribute that can be subdivided to yield additional attributes (ex; address)

    여러개의 속성을 합쳐서 하나로 부르는 것

    

  - Simple attribute: attribute that cannot be subdivided

    더이상 나눠지지 않는 특성

    

  - Single-valued attribute: attribute that has only a single value

    

  - Multivalued attributes: attributes that have many values

    - Create several new attributes, one for each component of the original multivalued attribute

    - Develop a new entity composed of the original multivalued attribute’s components

      

  - Derived attribute: whose value is calculated from other attributes

    - Derived using an algorithm 

      파생된 속성, 다른 속성들에서 계산되어 만들어진 속성/ 저장을 따로 안 하는게 원칙이지만 계산이 복잡한 경우나 속도를 증가시켜야 하는 경우는 저장할 수도 있다.



### 다중속성



기본 원칙은 단일 속성 (Simple attribute)을 유지하는 것이다.



다중 속성(Multivalued attributes)일 경우에는 단일 속성으로 나눠주어야 한다.



ex)

![1586236434128](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586236434128.png)



차의 색깔은 여러가지 색이 섞여있을 경우도 있으므로 별도의 Entity를 만들어주거나, Attribute를 single로 수정해줘야 한다.





### 파생속성



![1586236612658](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586236612658.png)



직원의 나이는 Day Of Birth(DOB)에서 자동으로 계산이 가능함.



이러한 경우는 저장을 따로 안 하는게 원칙이지만 계산이 복잡한 경우나 검색 속도를 증가시켜야 하는 경우는 저장할 수도 있다.







### Existence Dependence & Relationship Strength (의존성과 강한관계)



#### 의존성(Dependence)



![1586237019829](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586237019829.png)



부양가족 이라는 속성이 있을 때,



이러한 부양가족은 반드시 Employee와 연결이 되어야 한다. (직원이 없이 부양가족만 있을 수는 없음.)



#### 강한 관계



![1586237069639](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586237069639.png)





INVOICE 와 LINE처럼 관계가 설정 되어 있으며 INV_NUMBER라는 속성이 각각 프라이머리키와 포린키 관계로 연결 되있는 경우를 강한 관계(Strong relationship) 이라 하며,



LINE과 PRODUCT처럼 관계 설정은 되어있지만 공유하는 키가 없을 때느 Weak relationship 이라 한다.







### Weak Entity

![1586237330919](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586237330919.png)



Existence-dependet 가 있으면서, PK의 연관이 있을 경우(강한 연결)



#### 의존성이 있고 강한관계(PK를 이용하는)일 경우가 Weak Entity 이다.







### Relationship Degree (관계의 종류)

![1586237578982](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586237578982.png)

Unary relationship 은 하나의 Entity 내에서 서로 연결이 되는 경우 (ex 다른 사원의 사번(PK)을 FK로 받는 경우)



그 이후 2,3,4 개의 연결은 각각 binary, ternary, temary 라고 한다.



Binary (2) 예시

교수, 강의 : 1대다



Ternary (3) 예시

의사,환자,약 : 다 대 다 대다



Temary (4) 예시

의사 처방 약 환자 

의사 : 처방 은 1:다 

처방 : 환자 는 다:1

처방 : 약 은 다:1 (처방은 여러개일 수 도 있지만, 약은 하나?)





### ERD example

![1586238137737](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586238137737.png)



## Database Design Challenges



Database designers must often make design compromises that are triggered by **conflicting goals**

- Database design must conform to **design standards**
- High **processing speed** may limit the number and complexity of logically desirable relationships
- Information requirements
  - Maximum information generation may lead to loss of clean design structures and high transaction speed



### 설계원칙 (Design Challenges)

#### 정규화 를 최대한 진행 하라.(design standards)

데이터베이스의 **중복을 최소화** 하기위해서 테이블의 **종류를 최대한 분할**하는 것 



#### 속도를 높이기 위해서는?

정규화를 최대로 진행한 이후에, 다시 비정규화를 해서 관계표를 합치는 작업을 함



#### 정보요구

high transaction speed 때문에 모든 정규화 과정을 따를 수 없다.





### 설계 예시

![1586238684276](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586238684276.png)



1.직원 Entity에 사내결혼을 했다면 배우자의 사번을 입력하는 속성을 추가. 

2.직원 Entity와 연결된 사내결혼 Entity를 추가

3.사내결혼 Entity, 와 사내결혼과 직원의 중간에서 연결 되는 MARPART 2개를 추가



1,2,3 모두 가능한 설계로 설계자가 최적의 설계를 선택해야한다. (설계의 우선순위에 따라)



1,2번은 데이터 중복의 여부가 있고 ex)345,347에 각각 똑같은 결혼 데이터가 들어감

3은 검색 시간 증가의 우려가 있다.



#### *정규화? 

데이터 베이스를 효율적으로 하기 위해 분할하는 것.



### Specialization Hierarchy (상세계층)



![1586240022658](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586240022658.png)



한 종류의 Entity인데, 한 Entity의 부분집합 같은 식으로 하위집합을 별도로 분리해서 3개의 하위 Entity를 만들었는데 이 같은 경우를 상세화 계층이라고 한다.



![1586240126044](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586240126044.png)



#### Disjoint / Overlapping 제약조건



Disjoint, 아래의 subtype중에 한 곳에만 속할 수 있다.

Overlapping, 아래으 ㅣsubtype 중 여러곳에 속할 수 있다.





## Inheritance (상속)



![1586240295228](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586240295228.png)



사람이라는 기본 Entity의 정보를 직원과 학생 모두가 상속받는다. 



![1586240581502](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586240581502.png)

두줄의 O는 Overlapping constraint, 두가지 이외의 것은 해당X

ex) employee 와 student 두개다 해당 가능(대학원생), but 두 가지 이외의 것은 X





![1586240611422](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586240611422.png)

**한줄의 O**는 Overlapping 이지만 **incomplete(불안정한)**의 의미로, 두가지 이외의 다른 것들이 존재,

즉 교수이면서 관리자일 수 있지만, 두가지 이외의 다른 것일 수도 있다.



ex) 두줄의 d는 complete 이므로 아래의 두 종류 중 하나로 반드시 존재해야하므로 아래의 갯수의 합이 위의 Entity의 합이 된다. 

![1586240902521](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586240902521.png)





맨 아래에 위치한 Entity는 속성이 하나인가? -> X

맨 위의 Person / Employee, student 에서 속성들을 상속받는다.





## Entity Clustering

![1586241430721](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586241430721.png)



Entity Clustering 이란? 여러개의 Entity들을 묶어서 하나의 Class로 표현하는 것.



ex) 여기서의 OFFERING은 아래 사진의 SEMESTER, CLASS, COURSE 3개의 entity의 합(Entity Clustering)이다.



![1586241670462](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586241670462.png)





## Maintaining History of Time-Variant Data 

#### (시간이 지나면서 값이 바뀌는 데이터의 이력을 유지해야한다.)



![1586241790338](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586241790338.png)





전의 급여 역사와 부서 이동 역사 등등을 따로 관리해야한다 (Historic Data)



# 200409_W4D2_SQL,JOIN



## SQL의 종류

- Data definition language (DDL)
- Data manipulation language (DML)
- Transaction control language (TCL)
- Data control language (DCL)





## DDL(Data definition language)

테이블을 만들거나 지울 때 사용하는 명령어

##### CREATE, DROP, ALTER



### DML(Data manipulation language)

데이터베이스를 조작하는 명령어

##### SELECT, INSERT, UPDATE, DELETE, 

FROM,WHERE,GROUP BY, HAVING, ORDER BY, 

비교연산자 (>,<,=,<=,>=)

논리연산자(AND,OR,NOT)



### TCL (Transaction control language)

하나의 트랜잭션을 다루는 명령어

##### COMMIT, ROLLBACK, GRANT, REVOKE



##### Data type(자료형) 

Character(문자), 

Numeric(숫자), 

Date(날짜)가 있다.





SQL 쓰는법

select 컬럼이름 from 데이터베이스



alias = 별명, 데이터 베이스의 컬럼 같은 것을 짧게 변경해서 사용하는 경우







## SQL 사용 예시

![1586396935086](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586396935086.png)



PRODUCT 테이블의 모든 항목을 가져오는 것,





![1586396956298](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586396956298.png)

테이블의 특정 속성만을 가져오는 것,



![1586396977244](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586396977244.png)

속성을 가져오고 AS(Alias)로 이름을 바꾸는 것,



![1586397017169](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586397017169.png)



속성간의 연산 값을 가지는 속성을 만듬.



**나 ^인 제곱의 의미.





![1586398042053](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586398042053.png)

날짜 데이터 연산

INDATE에서 90일을 더한 값으로 EXPDATE 속성을 만들었다.









![1586398074277](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586398074277.png)

중복제거

DISTINCT 를 사용하면 중복 값들을 제거한 값을 보여준다.







## JOIN



#### Inner Join 

= 두개의 관계표를 합칠 때, 공동 자료항목을 기준으로 합치는데, 합치고 난 후에 공통 자료 항목이 같은 항목은 남기고 다른 결과들은 지우는 것,

즉, Common Value만 남기는 Join



#### Natural Join 

= Inner Join과 같은 의미, 공동 자료 항목을 찾고 자연스럽게 합쳐주는 것

공통 자료항목이 없으면 relational product를 남김.(단순 테이블의 곱)

![1586399115247](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586399115247.png)



#### USING Join

공통 자료항목이 있을 경우 USING뒤에 공통자료항목을 입력하면 해당 공통자료항목을 이용해서

JOIN을 한다.

-> Natural Join과 공통자료항목이 있을 때는 결과가 같지만 없을때는 Syntax Error가 나옴.

![1586399130559](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586399130559.png)





#### JOIN ON

특정 자료항목을 기준으로 JOIN을 할 경우 ON 뒤에 명시하여 JOIN 하는 기능

JOIN Condition을 만족하는 결과만 출력한다.

![1586399142355](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586399142355.png)





#### Outer Join 

= Inner Join의 항목을 남기고, 겹쳐지지 않는 항목 중에서도 일부를 남긴다.

*두 테이블의 자료를 전부 남기는 것을 Full Outer Join, 한쪽만 남기는 것을 Left, Right Join





![1586398198886](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586398198886.png)



예시로 사용할 테이블들



![1586398221444](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586398221444.png)

INVIOCE와  LINE을 첫 번째로 JOIN, INVOCIE.INV_NUMBER와 LINE.INV_NUMBER가 같은 경우에 JOIN을 하라고 명령함.



2번째 조인 : 위의 INVOICE와 LINE의 조인에 새로 PRODUCT를 JOIN함.

JOIN 조건은 LINE의 P_CODE와 PRODUCT의 P_CODE가 일치할 때,





*관계형 데이터베이스는 3개의 테이블을 한번에 조인할 수 없다. 그래서 1차 JOIN을 한 테이블에 다시 2차로 JOIN을 해 주는 방식을 사용해야 한다.







# 200414_W5D1_Aggregate,Grouping



## 전에한거 복습



## JOIN



#### Inner Join 

= 두개의 관계표를 합칠 때, 공동 자료항목을 기준으로 합치는데, 합치고 난 후에 공통 자료 항목이 같은 항목은 남기고 다른 결과들은 지우는 것,

즉, Common Value만 남기는 Join



#### Natural Join 

= Inner Join과 같은 의미, 공동 자료 항목을 찾고 자연스럽게 합쳐주는 것

공통 자료항목이 없으면 relational product를 남김.(단순 테이블의 곱)

![1586399115247](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586399115247.png)



#### USING Join

공통 자료항목이 있을 경우 USING뒤에 공통자료항목을 입력하면 해당 공통자료항목을 이용해서

JOIN을 한다.

-> Natural Join과 공통자료항목이 있을 때는 결과가 같지만 없을때는 Syntax Error가 나옴.

![1586399130559](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586399130559.png)





#### JOIN ON

특정 자료항목을 기준으로 JOIN을 할 경우 ON 뒤에 명시하여 JOIN 하는 기능

JOIN Condition을 만족하는 결과만 출력한다.

![1586399142355](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586399142355.png)





#### Outer Join 

= Inner Join의 항목을 남기고, 겹쳐지지 않는 항목 중에서도 일부를 남긴다.

*두 테이블의 자료를 전부 남기는 것을 Full Outer Join, 한쪽만 남기는 것을 Left, Right Join





![1586398198886](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586398198886.png)



예시로 사용할 테이블들



![1586398221444](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586398221444.png)

INVIOCE와  LINE을 첫 번째로 JOIN, INVOCIE.INV_NUMBER와 LINE.INV_NUMBER가 같은 경우에 JOIN을 하라고 명령함.



2번째 조인 : 위의 INVOICE와 LINE의 조인에 새로 PRODUCT를 JOIN함.

JOIN 조건은 LINE의 P_CODE와 PRODUCT의 P_CODE가 일치할 때,





*관계형 데이터베이스는 3개의 테이블을 한번에 조인할 수 없다. 그래서 1차 JOIN을 한 테이블에 다시 2차로 JOIN을 해 주는 방식을 사용해야 한다.







## 복습끝



#### Outer joins

- Returns not only the rows matching the join condition (rows with matching values in the common columns) and returns the rows with unmatched values
- ANSI standard defines three types of outer joins: **left, right, and full**

곱의 결과인 테이블에서 공통 자료 항목이 같은 row도 남기 는 것이 Inner Join이고, 공통자료 항목이 같지 않은 row도 남기는 Join

**left, right, full** 세 종류의 Outer Join이 있다.



#### Cross join

- Performs a relational product (also known as the *Cartesian product*) of two tables

  **한 쪽 테이블의 모든 행들과 다른 테이블의 모든 행을 조인**

  

  

#### Joining tables with an alias

테이블 조인을 할 때 별명을 붙여서 Join 가능

- An alias may be used to identify the source table from which the data is taken

- The ability to specify a table alias is very useful

  - Using a table alias allows the database programmer to improve the maintainability of the code by using a table alias that is descriptive of what data the table is providing within the query

    

#### Recursive joins

동일한 테이블을 Join 하는 것. ex) A와 A를 JOIN

- Recursive query: joins a table to itself







## Left Outer Join

![1586841585577](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586841585577.png)



왼쪽 테이블이 VENDOR 이므로, VENDOR의 데이터는 모두 남겨두고 일치하는 PRODUCT 테이블의 값이 있는 row의 값만 가져온다.



PRODUCT의 모든 데이터를 남기고 값이 일치하는 VENDOR만 가져올 때는 RIGHT JOIN





## 별명을 이용한 JOIN

![1586842044994](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586842044994.png)



PRODUCT 테이블을 P, VENDOR를 V라는 Alias를 지정하여 JOIN함.







## Recursive Join

![1586842188168](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586842188168.png)

EMP 테이블 2개를 조인하는데 Alias를 다르게 주어 E와 M 을 JOIN시킴.



주로 사번, 관리자번호 관리할 때 사용		







## ORDER BY

![1586842636256](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586842636256.png)



정렬의 기준을 정하는 명령어



FROM 절 아래, 보통 제일 뒤에 쓴다.





## WHERE 절



테이블 검색 조건을 지정하는 구문, 스킵가능

조건연산자 (AND,OR 등과 같이 사용 가능)

비교연산자 사용 가능

![1586842885904](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586842885904.png)





#### Selecting rows with conditional restrictions

- WHERE clause is used to add conditional restrictions to the SELECT statement that limit the rows returned by the query

- Syntax:

  SELECT   *columnlist*

  FROM   *tablelist*

  [WHERE   *conditionlist* ]

  [ORDER BY   *columnlist* [ASC | DESC] ];

  

#### Using comparison operators 

- on character attributes

- used to place restrictions on character-based attributes

- on dates

  - Date procedures are often more software-specific than other SQL procedures

    

#### Logical operators: AND, OR, and NOT

- SQL allows you to include multiple conditions in a query through the use of these logical operators
- Boolean algebra is dedicated to the use of logical operators





#### 예시

![1586842908635](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586842908635.png)



1번 : V_CODE가 21344와 같은 row

2번 : V_CODE가 21344가 아닌 row들만을 출력







## 날짜 데이터 조건문(Comparison Operators on Dates)

![1586843107355](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586843107355.png)

비교연산자를 이용해 조건문 설정이 가능하다.

2018-01-20 이후의 날짜들만 출력.







## WHERE 문에서의 특수 연산자

![1586843295451](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586843295451.png)



BETWEEN : 범위 내의 숫자만

IN : list 안에 값이 있는지 없는지,

LIKE : String Pattern이 비슷한 값이 있는지 없는지

IS NULL : 값이 null 인지 아닌지

NOT : 해당 값이 아닌.





#### 예시 - BETWEEN, IN

![1586843493445](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586843493445.png)



IN의 경우 21344~24288이 아니라, 21344나 24288 중 하나일 경우만.





#### 예시 - LIKE, NOT LIKE, IS NULL

![1586844459915](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586844459915.png)

Smith를 포함하는 String 만



NOT LIKE는 Smith를 포함하는 Stirng만을 제외



IS NULL은 해당 컬럼이 비어있는 row만.







## Aggregate Processing (집합, 합계 처리)



#### Takes a collection of rows and reduces it to a single row

- SQL provides useful aggregate functions that count, find minimum and maximum values, calculate averages, etc.

  

#### Aggregate functions (집합, 합계 함수)

- COUNT
- MIN and MAX
- SUM and AVG

![1586844821228](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586844821228.png)

이런 종류가 있음



select 문에서 사용하며, 값 하나만 리턴된다.



#### Grouping data

- GROUP BY clause syntax: 

  SELECT   *columnlist*

  FROM    *tablelist*

  [WHERE    *conditionlist* ]

  [GROUP BY   *columnlist* ]

  [ORDER BY    *columnlist* [ASC | DESC] ];



GROUP BY는 데이터들을 한 그룹으로 묶겠다는 의미.



합계함수(Aggregate functions)와 같이 사용하면 값이 하나가 아니라 Grouping 된 값의 수만큼 값이 나온다.

ex) 지역으로 그룹핑을 하면 지역별 평균이 나온다.





#### 예시 - 컬럼 내부 연산(TOTAL)

![1586844859581](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586844859581.png)



#### 예시 - 합계 함수 (Aggregate Processing)

![1586844938523](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586844938523.png)



##### COUNT나 AVG 등등은 SELECT 문에서 사용한다.



##### GROUP BY를 사용하여 V_CODE 별로 구분하여 평균을 구하였다.





## HAVING 절

![1586845817010](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586845817010.png)

GROUP BY의 결과에 적용되는 조건문



#### 예시 - HAVING, GROUP BY

![1586999278379](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1586999278379.png)



평균 가격(GROUP BY로 계산해야만 나옴)이 10보다 작은 값들만 출력,



즉 HAVING절은 반드시 GROUP BY랑 같이 쓰여야 한다.









## 서브쿼리(Subqueries)



서브쿼리는? 쿼리 안에 쿼리를 넣는 것

ex) where문, from절, IN, HAVING 안에 또 쿼리를 넣음



#### Key characteristics 

- A subquery is a query (SELECT statement) inside another query

- A subquery is normally expressed inside parentheses

- The first query in the SQL statement is known as the outer query

- The query inside the SQL statement is known as the inner query

- The inner query is executed first

- The output of an inner query is used as the input for the outer query

- The entire SQL statement is sometimes referred to as a nested query

  

#### Subquery can return one or more values

쿼리의 결과는 하나의 row,column이나 table 자체가 올 수 있다.

- One single value (one column and one row)
- A list of values (one column and multiple rows)
- A virtual table (multicolumn, multirow set of values)



## 서브쿼리의 종류

#### WHERE subqueries

- Most common type of subquery uses an inner SELECT subquery on the right side of a WHERE comparison expression

#### IN subqueries

- IN operator: used to compare a single attribute to a list of values
- IN subquery: values are not known beforehand, but can be derived using a query

#### HAVING subqueries 

- HAVING clause: used to restrict the output of a GROUP BY query by applying conditional criteria to the grouped rows
- Multirow subquery operators: ALL and ANY
- ALL operator compares a single value with a list of values returned by the first subquery using a comparison operator other than equals
- ANY operator compares a single value to a list of values and select only the rows greater than or less than any value in the list

#### FROM subqueries

- FROM clause specifies the table(s) from which the data will be drawn



where, in, having, from 절에 사용할 수 있다.



#### Attribute list subqueries

- Inline subquery: subquery expression
  - Example: can be used to list the difference between each product’s price and the average product price





#### Correlated subquery 

- Executes once for each row in the outer query
- Inner query is related to the outer query; the inner query references a column of the outer subquery
- Can also be used with the EXISTS special operator
  - Can be used whenever there is a requirement to execute a command based on the result of another query
  - Can be used with uncorrelated subqueries, but it is almost always used with correlated subqueries







# 200416_W5D2_서브쿼리,DDL





## 서브쿼리(Subqueries)



서브쿼리는? 쿼리 안에 쿼리를 넣는 것

ex) where문, from절, IN, HAVING 안에 또 쿼리를 넣음



#### Key characteristics 

- A subquery is a query (SELECT statement) inside another query

- A subquery is normally expressed inside parentheses

- The first query in the SQL statement is known as the outer query

- The query inside the SQL statement is known as the inner query

- The inner query is executed first

- The output of an inner query is used as the input for the outer query

- The entire SQL statement is sometimes referred to as a nested query

  

#### Subquery can return one or more values

쿼리의 결과는 하나의 row,column이나 table 자체가 올 수 있다.

- One single value (one column and one row)
- A list of values (one column and multiple rows)
- A virtual table (multicolumn, multirow set of values)



## 서브쿼리의 종류

#### WHERE subqueries

- Most common type of subquery uses an inner SELECT subquery on the right side of a WHERE comparison expression

#### IN subqueries

- IN operator: used to compare a single attribute to a list of values
- IN subquery: values are not known beforehand, but can be derived using a query

#### HAVING subqueries 

- HAVING clause: used to restrict the output of a GROUP BY query by applying conditional criteria to the grouped rows
- Multirow subquery operators: ALL and ANY
- ALL operator compares a single value with a list of values returned by the first subquery using a comparison operator other than equals
- ANY operator compares a single value to a list of values and select only the rows greater than or less than any value in the list

#### FROM subqueries

- FROM clause specifies the table(s) from which the data will be drawn



where, in, having, from 절에 사용할 수 있다.



#### Attribute list subqueries

- Inline subquery: subquery expression
  - Example: can be used to list the difference between each product’s price and the average product price





#### Correlated subquery 

- Executes once for each row in the outer query
- Inner query is related to the outer query; the inner query references a column of the outer subquery
- Can also be used with the EXISTS special operator
  - Can be used whenever there is a requirement to execute a command based on the result of another query
  - Can be used with uncorrelated subqueries, but it is almost always used with correlated subqueries







#### 예시 - HAVING 서브쿼리



![1587000248731](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587000248731.png)



예시1) HAVING 절 안에 서브쿼리를 활용하여 평균 갯수보다 많은 것만 출력



예시2) 서브쿼리를 활용한 테이블 2개를 JOIN







#### 예시 - WHERE, IN 서브쿼리



![1587000469447](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587000469447.png)





예시1 ) where 문에 서브쿼리를 주어 평균 가격보다 높거나 같은 가격을 가진 품목의 코드와 가격만 출력



예시2 ) where 문에 IN 서브쿼리를 주어 주석,설명에 hammer나 saw가 들어있는 PRODUCT만 출력 





## SQL 함수



#### SQL functions are very useful tools

- Many types 

#### Date and time functions - 날짜 시간 관련 함수

- All date functions take one parameter of a date or character data type and return a value; refer to Table 7.10

#### Numeric functions  - 숫자 관련 함수

- Can be grouped in many different ways, such as algebraic, trigonometric, and logarithmic; refer to Table 7.11

#### String functions - 문자열 관련 함수

- Among the most-used functions in programming; refer to Table 7.12 

#### Conversion functions - 데이터 타입 변환 함수

- Allow you to take a value of a given data type and convert it to the equivalent value in another data type; refer to Table 7.13





## ex)

#### UNION - 합집합 , 두테이블의 길이가 같아야함, 두 테이블을 합침

- Combines rows from two or more queries without including duplicate rows

- Syntax:

  *query* UNION *query*

#### UNION ALL - 합집합 + 중복된 row는 지워버림

- Used to produce a relation that retains the duplicate rows
- Used to unite more than just two queries

#### INTERSECT - 교집합, 두 테이블의 공통 row만 남겨놓음

- Can be used to combine rows from two queries, returning only the rows that appear in both sets

- Syntax:

  *query* INTERSECT *query*

#### EXCEPT (MINUS) - 차집합, 공통 row를 빼버림

- Combines rows from two queries and returns only the rows that appear in the first set but not in the second

- Syntax:

  *query* EXCEPT *query*

  *query* MINUS *query*

#### Syntax alternatives

- Alternative syntax used to achieve the same output







## Crafting SELECT Queries

#### Know your data - 데이터를 이해해야함.

- The importance of understanding the data model that you are working in cannot be overstated
- Real-world databases are messy; most database systems remain in service in an organization for decades

#### Know the problem - 문제를 파악해야함.

- Understand the question you are attempting to answer
- Information reporting requests will come from a range of sources; may be one-time events or ongoing operations within an application 

#### Build one clause at a time

- FROM
- WHERE
- GROUP BY
- HAVING
- SELECT
- ORDER BY







### SQL2 PPT로 이동



## Objectives

#### Use SQL to create a table manually

#### Use SQL to create a copy of a table using a subquery

#### Manipulate the structure of existing tables to add, modify, and remove columns and constraints

#### Use SQL to do data manipulation (insert, update, and delete rows of data)

#### Use SQL to create database views, including updatable views

#### Use Procedural Language SQL (PL/SQL) to create triggers, stored procedures, and PL/SQL functions

#### Create embedded SQL





요약 : 데이터베이스를 관리, 생성하는 파트



## 데이터베이스 생성 - 정의

![1587003791933](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587003791933.png)



만들기 전에 구조를 정의해야함,

인덱스 같은 스키마를 어떻게 할지

데이터 타입은 어떻게 할지





## DDL - 데이터베이스 생성, 삭제 관련 명령어

![1587003830439](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587003830439.png)







### 데이터 유형

![1587003859373](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587003859373.png)





## CREATE문

![1587004384451](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587004384451.png)





컬럼이름 + 데이터타입 , 컬럼이름2 + 테이터타입2, constraint(각 컬럼별로 줄 수도 있음.)







### 실제 예시

![1587004971357](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587004971357.png)

PK를 설정할때 CONSTRAINT PRODUCT_P_CODE_PK라는 제약조건을 넣어 PK 설정을 해줄 수도 있고, 생략할 수도 있다.





# 200421_W6D1_테이블 생성, 관리





#### 테이블 생성 예시1 - VENDOR, PRODUCT

![1587450716293](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587450716293.png)



#### 테이블 생성 예시2 - CUSTOMER, INVOICE

![1587450742385](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587450742385.png)



#### 테이블 생성 예시3 - LINE

![1587450916650](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587450916650.png)







## INDEX

![1587450934302](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587450934302.png)



검색기능, 데이터 중복을 막아주는 DB의 기능 중 하나



CREATE로만들고 DROP으로 삭제함.





## Altering Table Structures (테이블 변경 관련 명령어)



- All changes in the table structure are made by using the ALTER TABLE command followed by a keyword that produces the specific change you want to make

  - ##### ADD, MODIFY, and DROP 

    

- Changing a column’s data type

  - ##### ALTER 

    

- Changing a column’s data characteristics

  - If the column to be changed already contains data, you can make changes in the column’s characteristics if those changes do not alter the data type

    

- Adding a column

  - You can alter an existing table by adding one or more columns
  - Be careful not to include the NOT NULL clause for the new column





#### 사용예시

![1587451302809](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587451302809.png)



ALTER table 테이블이름 을 먼저 사용하고

ADD, DROP, MODIFY 등의 alter명령어를 사용한다.





## INSERT INTO - 테이블 행 추가하기 

![1587451487813](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587451487813.png)



사용방법 : INSERT INTO 테이블이름 VALUES(추가할 VALUES의 값들,값2,값3)



#### 사용 예시

![1587451534691](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587451534691.png)









#### SELECT 서브쿼리를 이용한 INSERT INTO

![1587451639340](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587451639340.png)





PRODUCT의 값들을 PART의 값에 복사하는 과정.



## 데이터베이스 상태 관리 명령어

#### -Saving table changes

- COMMIT command syntax: 

  COMMIT;

#### Updating table rows

- UPDATE command is used to modify data in a table

- UPDATE syntax:

  UPDATE   *tablename*

  SET  *columnname* = *expression* [, *columnname* = *expression*]

  [WHERE   *conditionlist* ];

#### Deleting table rows

- DELETE statement syntax:

  DELETE FROM   *tablename*

  [WHERE   *conditionlist* ];

#### -Restoring table contents

- ROLLBACK command is used restore the database to its previous condition

  ROLLBACK;





##### COMMIT : 현재의 변경 사항을 저장

##### ROLLBACK : 현재의 변경사항을 취소

UPDATE : 특정 테이블을 업데이트

DELETE : 특정 테이블을 삭제



## Virtual Tables: Creating a View

![1587451973715](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587451973715.png)



VIEW는 가상의 테이블 관점을 만들어서 테이블을 보다 간략하고 원하는 정보만 볼 수 있게 해준다.



#### VIEW UPDATE

![1587452167073](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587452167073.png)



SELECT * FROM 뷰 이름

으로 설정했던 뷰의 내용을볼 수 있고,



UPDATE 뷰 이름

set 컬럼이름 = 내용 

으로 뷰의 내용을 변경할 수 있다.



## Sequences - 번호 자동매기기

![1587452272570](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587452272570.png)



테이블을 생성할 때 자동으로 번호를 생성해주는 기능으로서 시작지점, 증가 범위, 증가or감소 여부 등을 설정할 수 있다.



## PL/SQL

절차적 SQL, 반복되는 SQL을 간단히 실행시키기 위한 기능



#### Performs a conditional or looping operation by isolating critical code and making all application programs call the shared code 

- Better maintenance and logic control



#### Persistent stored module (PSM): block of code 

- Contains standard SQL statements and procedural extensions that is stored and executed at the DBMS server

  

#### Procedural Language SQL (PL/SQL)

- Use and storage of procedural code and SQL statements within the database
- Merging of SQL and traditional programming constructs
- Procedural code is executed as a unit by DBMS when invoked by end user
- Anonymous PL/SQL blocks 
- Triggers
- Stored procedures 
- PL/SQL functions



MYSQL에서는 PSQL, oracle에서는 PL/SQL으로 이름이 다르다.





#### PL/SQL의 데이터 타입

![1587452423594](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587452423594.png)





#### 트리거

![1587452442741](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587452442741.png)



다음 시간에 이어서함.





# 200423_W6D2_트리거,트랜잭션



#### 트리거

![1587452442741](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587452442741.png)



PL/SQL이 자동적으로 실행되게 만들어주는 RDBMS 기능



Triggering timing : 어떤 때에 실행이 되게 할 지

Triggering event : 어떤 내용을 실행하게 할지 



ex)

![1588055482427](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588055482427.png)

판매량을 새로 업데이트 시켜주는 트리거, 

QOH는 현재 보유 개수, P_MIN은 최소 개수

 MIN_ORDER는 재주문 가능한 최소 수량 





ex2)

![1587605191276](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587605191276.png)



현재 보유 수량을 8->4로 바꿔서 최소 개수 이하로 떨어지자 REORDER 수가 증가하였다.



ex3)

![1587605230782](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587605230782.png)

최소 개수를 5->10개로 증가시켜서 REORDER 수가 1 늘어났다.





## Stored Procedures



프로그램을 작성해서 이름을 부여해서 DBMS에 저장을 해 놓는 것 



#### Named collection of procedural and SQL statements

- Stored in the database
- Can be used to encapsulate and represent business transactions

#### Advantages

- Reduce network traffic and increase performance
- Decrease code duplication by means of code isolation and code sharing 

##### 장점

코두 분리, 공유로 인해 코드 중복을 줄여줌

네트워크 트래픽을 줄여주고 성능 증가





ex) 재고가 최소 보유량의 2배 이상일 경우 5% 할인

![1587605973914](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587605973914.png)





## Cursor



커서 : SQL문을 실행할 때, 한 row씩 프로세싱을 해야하는 프로그램을 짜야할 때 사용함.





#### Cursor: special construct used to hold data rows returned by a SQL query - 데이터 열들을 한꺼번에 다루는 SQL 쿼리

- Implicit cursor: automatically created when SQL statement returns only one value

  DBMS가 알아서 만들어서 실행하는 커서

- Explicit cursor: holds the output of a SQL statement that may return two or more rows

  유저가 직접 만들어서 실행되는 커서

- Syntax:

  CURSOR *cursor_name* IS *select-query*;

  

#### Cursor-style processing involves retrieving data from the cursor one row at a time - 한번에 data를 다룰 필요가 있을 때 커서를 사용함

- Current row is copied to PL/SQL variables





## Cursor 사용법

![1587606470318](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587606470318.png)





일단 OPEN을 하고, FETCH로 row들을 읽어야 한다.





## Stored function 과 Embedded SQL의 차이 

#### Stored function: named group of procedural and SQL statements that returns a value - 리턴 값을 가짐

- Indicated by a RETURN statement in its program code

#### Can be invoked only from within stored procedures or triggers - 트리거나 procedures 안에서 실행되어야함.

- Cannot be invoked from SQL statements unless the function follows some very specific compliance rules





## Embedded SQL - 내장된 범용 프로그래밍 언어  

#### SQL statements contained within an application programming language

- Host language: any language that contains embedded SQL statements

  -내장 범용 언어 ex) 자바, 파이썬

#### Differences between SQL and procedural languages

- Run-time mismatch

  - SQL is executed one instruction at a time
  - Host language runs at client side in its own memory space

- Processing mismatch

  - Conventional programming languages process one data element at a time
  - Newer programming environments manipulate data sets in a cohesive manner

- Data type mismatch

  - Data types provided by SQL might not match data types used in different host languages

  



![1587606965177](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587606965177.png)

특정 코드들을 이용해 HOST와 소통함.









## 3장 - 다수의 사용자의 트랜잭션을 컨트롤 하는 방법



locking methods

stamping methods

optimistic methods

3가지 방법이 있음.





## 트랜잭션이란?

전체적으로 처리가 다 끝나거나 중단되야하는 논리적인 한 단위 



하나 또는 그 이상의 데이터베이스 요청의 집합.



#### A logical unit of work that must be entirely completed or aborted

- A sequence of database requests that accesses the database
- Consists of:
  - SELECT statement 
  - Series of related UPDATE statements
  - Series of INSERT statements
  - Combination of SELECT, UPDATE, and INSERT statements



#### Consistent database state

- All data integrity constraints are satisfied
- Must begin with the database in a known consistent state to ensure consistency
- Most are formed by two or more database requests
  - A database request: equivalent of a single SQL statement in an application program or transaction



모든 데이터 무결성이 지켜졌을때 Consistent (일관성있는) DB라 한다.



#### Evaluating Transaction Results 

- Not all transactions update the database
  - SQL code represents a transaction because it accesses the database
- Improper or incomplete transactions can have devastating effect on database integrity
  - Users can define enforceable constraints based on business rules
  - Other integrity rules are automatically enforced by the DBMS





ex)

![1587608211201](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587608211201.png)





이 과정에서 하나의 DB만 업데이트 되면 안되고, 상품이 하나 팔리면 INVOICE(송장), PRODUCT ,CUSTOMER 등등 다양한 DB도 함께 업데이트 되야한다.









## 트랜잭션 예시

![1587608954964](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587608954964.png)



물건 하나를 구매했을 때, 



INOVICE와 LINE 테이블에 각각 row 하나를 추가하고

PRODUCT, CUSTOMER 테이블을 업데이트하고

ACCT_TRANSACTION 에 새로 row를 업데이트를 해야 (ACCOUNT_TRANSACTION)



5가지 구문이 전부 완료가 되어야 하나의 트랜잭션이 끝난다.

-> 임시 저장되어있던 값들을 COMMIT으로 영구저장





![1587609203537](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587609203537.png)

트랜잭션을 처리하는 중간에 전기가 꺼져서 과정이 중단될 경우?

데이터 일관성이 깨지게 됨.



#### -> 처리하기 전 상태로 되돌려야함 (ROLLBACK)



## 트랜잭션의 특징(ACID+S)

#### Atomicity - 원자성, 더 이상 분해되지 않는 논리적인 작업단위

- All operations of a transaction must be completed; 
  if not, the transaction is aborted
- a single, indivisible, logical unit of work

#### Consistency - 일관성, 하나의 작업은 마칠 때 연관된 상태로 저장되어야 함

- Permanence of database’s consistent state

#### Isolation - 고립성, 트랜잭션은 하나가 온전히 끝난 뒤에야 다음 트랜잭션이 실행됨, 즉 서로 겹쳐지지않음, 

- Data used during a transaction cannot be used by second transaction until the first is completed

#### Durability  - 지속성, 트랜잭션이 끝나면 undone상태로 되돌릴 수 없음

- Ensures that once transactions are committed, they cannot be undone or lost

#### Serializability - 순차성, 동시에 실행되는 트랜잭션을 잘 관리해서 일관적인 결과가 나와야함.

- Ensures that the schedule for the concurrent execution of several transactions should yield consistent results



멀티유저가 사용하는 DB의 경우 Isolation 과 Serializability  의 관리가 매우 중요함.





## SQL이 제공하는 트랜잭션 관리 기능

![1587609844637](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587609844637.png)



##### COMMIT, ROLLBACK으로 트랜잭션을 관리한다.



트랜잭션은 4가지 경우에서 계속 이어진다.

1.commit이 되기 전까지

2.rollback 이 나오기 전 까지

3.프로그램이 끝나기 전까지(트리거나 절차적SQL이 끝날 때)

4.프로그램이 비정상으로 종료되기 전까지



# 200428_W7D1_병행관리,Locking



## 트리거 수정

#### 트리거

![1587452442741](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587452442741.png)



PL/SQL이 자동적으로 실행되게 만들어주는 RDBMS 기능



Triggering timing : 어떤 때에 실행이 되게 할 지

Triggering event : 어떤 내용을 실행하게 할지 



ex)

![1588055482427](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588055482427.png)

판매량을 새로 업데이트 시켜주는 트리거, 

#### QOH는 현재 보유 개수, P_MIN은 최소 개수

 MIN_ORDER는 재주문 가능한 최소 수량 





ex2)

![1587605191276](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587605191276.png)



현재 보유 수량을 8->4로 바꿔서 최소 개수 이하로 떨어지자 REORDER 수가 증가하였다.



ex3)

![1587605230782](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1587605230782.png)

최소 개수를 5->10개로 증가시켜서 REORDER 수가 1 늘어났다.



![1588055810412](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588055810412.png)





새로운 LINE_UNILTS가 들어오면 **현재 갯수**를 업데이트 한다.







## 트랜잭션 로그

![1588055974475](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588055974475.png)





트랜잭션에 대한 기록을 저장하는 곳





## Concurrency Control (병행성 관리)

![1588056041127](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D%EC%8B%A4%EC%8A%B5/1588056041127.png)

시스템이 동시에 실행될 때 병행성을 관리해주는 것을 의미한다.



주 문제 는 3개로

##### 업데이트 과정 중 손실되거나

##### commit 되지 않은 데이터

##### 일관되지 않은 검색 

> 트랜잭션이 업데이트 전, 후로 검색 데이터가 다른 것을 의미





#### 업데이트 손실 예시

![1588056188925](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588056188925.png)





#### Commit 실패 예시

![1588056205941](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588056205941.png)





#### 일관되지 않은 검색 예시

![1588056223331](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588056223331.png)



![1588056238022](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588056238022.png)







## 스케쥴러



![1588056264342](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588056264342.png)





트랜잭션의 충돌을 방지하기 위해 concurrent control(병행성 관리) 알고리즘으로



각 트랜잭션을 시간적 순서에 맞춰 실행하게 해주는 것 





## Locking Method

## ![1588056319199](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588056319199.png)



실행 순서를 맞추기 위해서 잠구는 것 

다양한 방법이 있음.





## Lock 세분화(Granularity)

#### 데이터베이스 레벨 Locking

![1588056387304](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588056387304.png)





#### 테이블 레벨 Locking

![1588056405487](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588056405487.png)





#### 페이지 레벨 Locking

![1588056422434](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588056422434.png)





#### row 레벨 locking

![1588056437720](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588056437720.png)







## Lock의 Types

![1588056477026](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588056477026.png)



binary로 1,0으로 구분을 할 수 있고



read,write,lock,unlock등 세분화해서 상태를 나누는 방법도 있다.







## 데드락

![1588056580815](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588056580815.png)





locks를 사용하다가 순차성이 깨지게 될 경우 스케쥴이 잘 작동하지 않게 되어 데드락을 생성하게 된다.



![1588056745652](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588056745652.png)





두 트랜잭선이 서로 unlock상태의 데이터를 기다리는 상태



컨트롤 방법은 3가지가 있음.

Deadlock prevention(예방)

Deadlock detection(감지)

Deadlock avoidance(회피)









![1588056843379](../../20%EB%85%84%201%ED%95%99%EA%B8%B0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B4%80%EB%A6%AC/assets/1588056843379.png)



Locking을 2Phases로 나눠서 관리하는 방법

Growing(성장)과

Shrinking(축소) 페이즈로 나누며



성장 단계에서 트랜잭션의 lcoks를 가지게 되고

축소 단계에서 모든 lock이 해제됨.(새로운 lock을 얻지 못함)